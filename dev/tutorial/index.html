<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ConstraintSolver</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ConstraintSolver logo"/></a><div class="docs-package-name"><span class="docs-autofit">ConstraintSolver</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Sudoku"><span>Sudoku</span></a></li><li><a class="tocitem" href="#Graph-coloring"><span>Graph coloring</span></a></li><li class="toplevel"><a class="tocitem" href="#Bound-computation"><span>Bound computation</span></a></li></ul></li><li><a class="tocitem" href="../how_to/">How-To</a></li><li><a class="tocitem" href="../options/">Solver options</a></li><li><a class="tocitem" href="../supported/">Supported/Planned</a></li><li><a class="tocitem" href="../explanation/">Explanation</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Wikunia/ConstraintSolver.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This is a series of tutorials to solve basic problems using the constraint solver.</p><p>Before we tackle some problems we first have to install the constraint solver.</p><pre><code class="language-none">$ julia
] add ConstraintSolver</code></pre><p>Then we have to use the package with:</p><pre><code class="language-none">using ConstraintSolver
const CS = ConstraintSolver</code></pre><p>additionally we need to include the modelling package <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP.jl</a> with:</p><pre><code class="language-none">using JuMP</code></pre><p>Solving:</p><ul><li><a href="#Sudoku-1">Sudoku</a></li><li><a href="#Graph-coloring-1">Graph coloring</a></li><li><a href="#Bound-computation-1">Better bound computation</a></li></ul><h2 id="Sudoku"><a class="docs-heading-anchor" href="#Sudoku">Sudoku</a><a id="Sudoku-1"></a><a class="docs-heading-anchor-permalink" href="#Sudoku" title="Permalink"></a></h2><p>Everybody knows sudokus and for some it might be fun to solve them by hand. Today we want to use this constraint solver to let the computer do the hard work.</p><p>Rules of sudoku:</p><ul><li>We have 9x9 grid each cell contains a digit or is empty initially</li><li>We have nine 3x3 blocks </li><li>In the end we want to fill the grid such that<ul><li>Each row, column and block should have the digits 1-9 exactly once</li></ul></li></ul><p>We now have to translate this into code:</p><p>Defining the grid:</p><pre><code class="language-none">grid = [6 0 2 0 5 0 0 0 0;
        0 0 0 0 0 3 0 4 0;
        0 0 0 0 0 0 0 0 0;
        4 3 0 0 0 8 0 0 0;
        0 1 0 0 0 0 2 0 0;
        0 0 0 0 0 0 7 0 0;
        5 0 0 2 7 0 0 0 0;
        0 0 0 0 0 0 0 8 1;
        0 0 0 6 0 0 0 0 0]</code></pre><p><code>0</code> represents an empty cell. Then we need a variable for each cell:</p><pre><code class="language-none"># creating a constraint solver model and setting ConstraintSolver as the optimizer.
m = Model(CS.Optimizer) 
# define the 81 variables
@variable(m, 1 &lt;= x[1:9,1:9] &lt;= 9, Int)
# set variables if fixed
for r=1:9, c=1:9
    if grid[r,c] != 0
        @constraint(m, x[r,c] == grid[r,c])
    end
end</code></pre><p>For the empty cell we create a variable with possible values <code>1-9</code> and otherwise we do the same but fix the value to the given cell value.</p><p>Then we define the constraints:</p><pre><code class="language-none">for rc = 1:9
    @constraint(m, x[rc,:] in CS.AllDifferentSet())
    @constraint(m, x[:,rc] in CS.AllDifferentSet())
end</code></pre><p>For each row and column (1-9) we create an <code>AllDifferent</code> constraint which specifies that all the variables should have a different value in the end using <code>CS.AllDifferentSet()</code>. As there are always nine variables and nine digits each value 1-9 is set exactly once per row and column.</p><p>Now we need to add the constraints for the 3x3 blocks:</p><pre><code class="language-none">for br=0:2
    for bc=0:2
        @constraint(m, vec(x[br*3+1:(br+1)*3,bc*3+1:(bc+1)*3]) in CS.AllDifferentSet())
    end
end</code></pre><p>Then we call the solve function of JuMP called <code>optimize</code> with the model as the only parameter.</p><pre><code class="language-none">optimize!(m)</code></pre><p><strong>Attention:</strong> This might take a while for the first solve as everything needs to be compiled but the second time it will be fast.</p><p>The status of the model can be extracted by:</p><pre><code class="language-none">status = JuMP.termination_status(m)</code></pre><p>This returns a <a href="https://github.com/JuliaOpt/MathOptInterface.jl">MOI</a> StatusCode which are explained <a href="http://www.juliaopt.org/JuMP.jl/v0.19.2/solutions/#MathOptInterface.TerminationStatusCode">here</a>.</p><p>In our case it returns <code>MOI.OPTIMAL</code>. If we want to get the solved sudoku we can use:</p><pre><code class="language-none">@show convert.(Integer,JuMP.value.(x))</code></pre><p>which outputs:</p><pre><code class="language-none">6  8  2  1  5  4  3  7  9
9  5  1  7  6  3  8  4  2
3  7  4  8  9  2  1  6  5
4  3  7  5  2  8  9  1  6
8  1  6  9  3  7  2  5  4
2  9  5  4  1  6  7  3  8
5  6  8  2  7  1  4  9  3
7  2  9  3  4  5  6  8  1
1  4  3  6  8  9  5  2  7</code></pre><p>If you want to get a single value you can i.e use <code>JuMP.value(com_grid[1])</code>.</p><p>In the next part you&#39;ll learn a different constraint type and how to include an optimization function.</p><h2 id="Graph-coloring"><a class="docs-heading-anchor" href="#Graph-coloring">Graph coloring</a><a id="Graph-coloring-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-coloring" title="Permalink"></a></h2><p>The goal is to color a graph in such a way that neighboring nodes have a different color. This can also be used to color a map.</p><p>We want to find the coloring which uses the least amount of colors.</p><pre><code class="language-none">m = Model(CS.Optimizer)
num_colors = 10

@variable(m, 1 &lt;= countries[1:5] &lt;= num_colors, Int)
germany, switzerland, france, italy, spain = countries</code></pre><p>I know this is only a small example but you can easily extend it. In the above case we assume that we don&#39;t need more than 10 colors.</p><p>Adding the constraints:</p><pre><code class="language-none">@constraint(m, germany != france)
@constraint(m, germany != switzerland)
@constraint(m, france != spain)
@constraint(m, france != switzerland)
@constraint(m, france != italy)
@constraint(m, switzerland != italy)</code></pre><p>If we call <code>optimize!(m)</code> now we probably don&#39;t get a coloring with the least amount of colors.</p><p>We can get this by adding:</p><pre><code class="language-none">@variable(m, 1 &lt;= max_color &lt;= num_colors, Int)
@constraint(m, max_color .&gt;= countries)
@objective(m, Min, max_color)
optimize!(m)
status = JuMP.termination_status(m)</code></pre><p>We can get the value for each variable using <code>JuMP.value(germany)</code> for example or as before print the values:</p><pre><code class="language-none">println(JuMP.value.(countries))</code></pre><p>and getting the maximum color used with </p><pre><code class="language-none">println(&quot;#colors: $(JuMP.value(max_color))&quot;)</code></pre><h1 id="Bound-computation"><a class="docs-heading-anchor" href="#Bound-computation">Bound computation</a><a id="Bound-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Bound-computation" title="Permalink"></a></h1><p>In this section you learn how to combine the alldifferent constraint and a sum constraint as well as using an objective function. When using a linear objective function it is useful to get good bounds to find the optimal solution faster and proof optimality. There is a very very basic bound computation build into the ConstraintSolver itself by just having a look at the maximum and minium values per variable. However this is a very bad estimate most of the time i.e for less than constraints.</p><p>If we have</p><pre><code class="language-none">m = Model(CS.Optimizer) 
@variable(m, 0 &lt;= x[1:10] &lt;= 15, Int)
@constraint(m, sum(x) &lt;=  15)
@objective(m, Max, sum(x))</code></pre><p>Each variable itself can have all values but the objective bound is of course <span>$15$</span> and not <span>$150$</span>. Instead of building this directly into the ConstraintSolver I decided  to instead get help by a linear solver of your choice. You can use this with the option <code>lp_optimizer</code>:</p><pre><code class="language-none">cbc_optimizer = optimizer_with_attributes(Cbc.Optimizer, &quot;logLevel&quot; =&gt; 0)
m = Model(optimizer_with_attributes(
    CS.Optimizer,
    &quot;lp_optimizer&quot; =&gt; cbc_optimizer,
))
@variable(m, 0 &lt;= x[1:10] &lt;= 15, Int)
@constraint(m, sum(x) &lt;=  15)
@objective(m, Max, sum(x))
optimize!(m)</code></pre><p>It creates an <code>LP</code> with all supported constraints so <code>&lt;=, &gt;=, ==</code>. The ConstraintSolver will then work as the branch and bound part to solve the discrete problem. This is currently slower for problems that you can formulate directly as a MIP as the one above but now you can solve problems like:</p><pre><code class="language-none">cbc_optimizer = optimizer_with_attributes(Cbc.Optimizer, &quot;logLevel&quot; =&gt; 0)
m = Model(optimizer_with_attributes(
    CS.Optimizer,
    &quot;lp_optimizer&quot; =&gt; cbc_optimizer,
))
@variable(m, 0 &lt;= x[1:10] &lt;= 15, Int)
@constraint(m, sum(x) &gt;= 10)
@constraint(m, x[1:5] in CS.AllDifferentSet())
@constraint(m, x[6:10] in CS.AllDifferentSet())
@objective(m, Min, sum(x))
optimize!(m)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../how_to/">How-To »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 13 February 2021 15:49">Saturday 13 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
